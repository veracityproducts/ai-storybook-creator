// PDF Export functionality for storybooks
// Uses jsPDF and html2canvas for client-side PDF generation

import { jsPDF } from 'jspdf'
import html2canvas from 'html2canvas'
import type { BookData } from '@/components/book-reader'

export interface PDFExportOptions {
  format?: 'a4' | 'letter' | 'custom'
  orientation?: 'portrait' | 'landscape'
  quality?: number
  includeMetadata?: boolean
  customSize?: { width: number; height: number }
}

export class BookPDFExporter {
  private book: BookData
  private options: Required<PDFExportOptions>

  constructor(book: BookData, options: PDFExportOptions = {}) {
    this.book = book
    this.options = {
      format: options.format || 'a4',
      orientation: options.orientation || 'portrait',
      quality: options.quality || 0.95,
      includeMetadata: options.includeMetadata ?? true,
      customSize: options.customSize || { width: 210, height: 297 }
    }
  }

  async exportToPDF(): Promise<void> {
    try {
      // Create PDF document
      const pdf = new jsPDF({
        orientation: this.options.orientation,
        unit: 'mm',
        format: this.options.format === 'custom' 
          ? [this.options.customSize.width, this.options.customSize.height]
          : this.options.format
      })

      // Add metadata
      if (this.options.includeMetadata) {
        pdf.setProperties({
          title: this.book.title,
          subject: this.book.theme || 'Decodable Reader',
          author: 'StoryMaker AI',
          creator: 'StoryMaker AI - Decodable Reader Generator',
          keywords: `decodable reader, children's book, ${this.book.ageRange || 'early reader'}`
        })
      }

      // Get page dimensions
      const pageWidth = pdf.internal.pageSize.getWidth()
      const pageHeight = pdf.internal.pageSize.getHeight()
      const margin = 10

      // Add cover page
      await this.addCoverPage(pdf, pageWidth, pageHeight, margin)

      // Add story pages
      for (let i = 0; i < this.book.pages.length; i++) {
        pdf.addPage()
        await this.addStoryPage(pdf, this.book.pages[i], i, pageWidth, pageHeight, margin)
      }

      // Add back cover with moral (if exists)
      if (this.book.moral) {
        pdf.addPage()
        await this.addBackCover(pdf, pageWidth, pageHeight, margin)
      }

      // Save the PDF
      const filename = `${this.book.title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.pdf`
      pdf.save(filename)

    } catch (error) {
      console.error('Error generating PDF:', error)
      throw new Error('Failed to generate PDF. Please try again.')
    }
  }

  private async addCoverPage(pdf: jsPDF, pageWidth: number, pageHeight: number, margin: number): Promise<void> {
    // Title
    pdf.setFontSize(24)
    pdf.setFont('helvetica', 'bold')
    const titleLines = pdf.splitTextToSize(this.book.title, pageWidth - 2 * margin)
    const titleHeight = titleLines.length * 8
    pdf.text(titleLines, pageWidth / 2, pageHeight / 3, { align: 'center' })

    // Theme/subtitle
    if (this.book.theme) {
      pdf.setFontSize(14)
      pdf.setFont('helvetica', 'normal')
      const themeLines = pdf.splitTextToSize(this.book.theme, pageWidth - 2 * margin)
      pdf.text(themeLines, pageWidth / 2, pageHeight / 3 + titleHeight + 10, { align: 'center' })
    }

    // Age range
    if (this.book.ageRange) {
      pdf.setFontSize(12)
      pdf.setFont('helvetica', 'italic')
      pdf.text(`Age Range: ${this.book.ageRange}`, pageWidth / 2, pageHeight * 2/3, { align: 'center' })
    }

    // Footer
    pdf.setFontSize(10)
    pdf.setFont('helvetica', 'normal')
    pdf.text('Generated by StoryMaker AI', pageWidth / 2, pageHeight - margin, { align: 'center' })
  }

  private async addStoryPage(
    pdf: jsPDF, 
    page: BookData['pages'][0], 
    pageIndex: number, 
    pageWidth: number, 
    pageHeight: number, 
    margin: number
  ): Promise<void> {
    try {
      // Load and add image
      const img = new Image()
      img.crossOrigin = 'anonymous'
      
      await new Promise<void>((resolve, reject) => {
        img.onload = () => resolve()
        img.onerror = () => reject(new Error(`Failed to load image for page ${pageIndex + 1}`))
        img.src = page.url
      })

      // Calculate image dimensions (maintain aspect ratio)
      const maxImageWidth = pageWidth - 2 * margin
      const maxImageHeight = (pageHeight - 2 * margin) * 0.7 // Leave space for text
      
      const imgAspectRatio = img.width / img.height
      let imgWidth = maxImageWidth
      let imgHeight = imgWidth / imgAspectRatio

      if (imgHeight > maxImageHeight) {
        imgHeight = maxImageHeight
        imgWidth = imgHeight * imgAspectRatio
      }

      // Center the image
      const imgX = (pageWidth - imgWidth) / 2
      const imgY = margin + 10

      // Add image to PDF
      const canvas = document.createElement('canvas')
      const ctx = canvas.getContext('2d')!
      canvas.width = img.width
      canvas.height = img.height
      ctx.drawImage(img, 0, 0)
      
      const imgData = canvas.toDataURL('image/jpeg', this.options.quality)
      pdf.addImage(imgData, 'JPEG', imgX, imgY, imgWidth, imgHeight)

      // Add page text
      const textY = imgY + imgHeight + 15
      pdf.setFontSize(16)
      pdf.setFont('helvetica', 'normal')
      
      const textLines = pdf.splitTextToSize(page.text, pageWidth - 2 * margin)
      pdf.text(textLines, pageWidth / 2, textY, { align: 'center' })

      // Add page number
      pdf.setFontSize(10)
      pdf.setFont('helvetica', 'normal')
      pdf.text(`${pageIndex + 1}`, pageWidth / 2, pageHeight - margin / 2, { align: 'center' })

    } catch (error) {
      console.error(`Error adding page ${pageIndex + 1}:`, error)
      // Add error placeholder
      pdf.setFontSize(14)
      pdf.text(`[Image could not be loaded for page ${pageIndex + 1}]`, pageWidth / 2, pageHeight / 2, { align: 'center' })
      
      // Still add the text
      pdf.setFontSize(16)
      const textLines = pdf.splitTextToSize(page.text, pageWidth - 2 * margin)
      pdf.text(textLines, pageWidth / 2, pageHeight / 2 + 20, { align: 'center' })
    }
  }

  private async addBackCover(pdf: jsPDF, pageWidth: number, pageHeight: number, margin: number): Promise<void> {
    // Moral of the story
    pdf.setFontSize(18)
    pdf.setFont('helvetica', 'bold')
    pdf.text('Moral of the Story', pageWidth / 2, pageHeight / 3, { align: 'center' })

    pdf.setFontSize(14)
    pdf.setFont('helvetica', 'italic')
    const moralLines = pdf.splitTextToSize(this.book.moral!, pageWidth - 2 * margin)
    pdf.text(moralLines, pageWidth / 2, pageHeight / 3 + 20, { align: 'center' })

    // Generation info
    if (this.book.costInfo) {
      pdf.setFontSize(10)
      pdf.setFont('helvetica', 'normal')
      const info = [
        `Generated with ${this.book.costInfo.model}`,
        `${this.book.costInfo.imagesGenerated} AI-generated illustrations`,
        `Cost: $${this.book.costInfo.totalImageCost.toFixed(2)} ${this.book.costInfo.currency}`
      ]
      
      let yPos = pageHeight * 2/3
      info.forEach(line => {
        pdf.text(line, pageWidth / 2, yPos, { align: 'center' })
        yPos += 5
      })
    }
  }
}

// Utility function for easy export
export async function exportBookToPDF(book: BookData, options?: PDFExportOptions): Promise<void> {
  const exporter = new BookPDFExporter(book, options)
  await exporter.exportToPDF()
}
